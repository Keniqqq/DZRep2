## Задача JVM

### Подготовка к запуску: Загрузка класса
Прежде чем начнётся выполнение main, JVM загружает класс JvmComprehension через Bootstrap ClassLoader , затем через Platform ClassLoader или App ClassLoader , в зависимости от контекста.

Класс загружается и проверяется.
Статические данные класса (например, статические поля) инициализируются.
Информация о классе хранится в Metaspace (начиная с Java 8).
### Описание строк
Строка 1: int i = 1;
_____
Создаётся локальная переменная примитивного типа int .
Хранится в стековом фрейме метода main .
Не участвует в сборке мусора.
____
Строка 2: Object o = new Object();
***
Выделяется память под объект Object в куче (heap) .
В стеке создаётся ссылочная переменная o, указывающая на этот объект.
Класс Object уже загружен Bootstrap ClassLoader'ом .
Объект может быть собран GC, если станет недостижимым.
***
Строка 3: Integer ii = 2;
***
Это пример автобоксинга : компилятор преобразует это в Integer.valueOf(2).
Для чисел от -128 до 127 используется кэшированный объект из пула IntegerCache.
Таким образом, ii ссылается на уже существующий объект в куче .
Если бы число было вне диапазона, был бы создан новый объект в куче.
Переменная ii хранится в стеке .
***
Строка 4: printAll(o, i, ii);
***
Происходит вызов метода **printAll**.
В стеке создаётся новый фрейм для метода printAll.
**Передаются параметры:**

Object o (ссылка на объект в куче),

int i (примитив, передаётся по значению),

Integer ii (ссылка на объект в куче).

Все они будут доступны внутри нового стекового фрейма метода printAll.

***
Строка 5: Integer uselessVar = 700;
***
Создаётся новый объект Integer со значением 700.
Так как 700 > 127, он не берётся из кэша , а создаётся новый объект в куче .
Ссылка uselessVar хранится в стеке , сам объект — в куче .
После завершения метода ссылка исчезнет, объект может быть собран GC.
***
Строка 6: System.out.println(o.toString() + i + ii);
***
Вызывается метод toString() у объекта o. 

Это виртуальный вызов, который разрешается динамически.
**Происходит конкатенация строк:**

i (примитив) автобоксится в Integer, затем в String.

ii (уже объект Integer) тоже преобразуется в String.

Конкатенация порождает новые строки в куче (возможно, используя StringBuilder).
System.out — это статическое поле класса PrintStream, загруженное ранее.
Метод println выводит результат в стандартный поток вывода.
***
Строка 7: System.out.println("finished");
***
"finished" — строковая константа. Она находится в пуле строк (string pool) , который находится в куче .
Используется существующий объект из пула.
Вызывается метод println, выводится текст в консоль.
***
### Графическая схема (текстовое представление)

[Метаспейс]
|

|-- JvmComprehension.class (загружен AppClassLoader)

|-- Object.class (BootstrapClassLoader)

|-- Integer.class (BootstrapClassLoader)

|-- String.class

|-- PrintStream.class
***
[Стек]
|

|-- main(args) фрейм
|   |\
|   |-- int i = 1\
|   |-- Object o → [heap: Object@...]\
|   |-- Integer ii → [heap: Integer(2)] (из кэша)\
|\
|-- printAll(o, i, ii) фрейм\
|\
|-- Object o → [heap: Object@...] (та же ссылка)\
|-- int i = 1\
|-- Integer ii → [heap: Integer(2)]\
|-- Integer uselessVar → [heap: Integer(700)]\
****
[стэк]\
|\
|-- Object@...\
|-- Integer(2) (из кэша)\
|-- Integer(700) (новый объект)\
|-- String "finished" (из string pool)\
|-- временные String объекты при конкатенации

### Сборка мусора
Объект **new Object() (o)** становится недостижимым после выхода из main, если нет внешней ссылки.\
**Integer(700) (uselessVar)** становится недостижимым после выхода из printAll.\
Эти объекты могут быть собраны GC при следующем цикле сборки.\
Объект **Integer(2)** не будет собран, так как он из кэша и может использоваться другими частями программы.